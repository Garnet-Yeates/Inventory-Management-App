
import mysql from 'mysql2'

/**
 * Here is how we will do authentication
 * 
 * We will use JWT token but be smart about how we store it. We will also use SQL to make them
 * more dynamic and cancellable
 * 
 * We will use the "double submit" strategy to prevent CSRF attack
 * 
 * Using the cookie itself as a form of authorization is dangerous, because other sites could could
 * socially-engineer you into clicking a link / running a script on their site that will make a request
 * a request in your browser. Since your browser will automatically send cookies it is dangerous because
 * they can make whatever request they want on your behalf (if your server architecture is set up in a way to
 * authorize based on the presence of the cookie)
 * 
 * To get around this we take advantage of a caveat of readable cookies on safe browsers: which is that on "normal/secure"
 * browsers like chrome, JavaScript code that is running on one website cannot read the cookies of other
 * websites. So what we do is instead of using cookies itself to authorize, we store authorizing info
 * (i.e the JWT token) in one cookie but we also have another cookie called the CSRF cookie that stores an arbritrary code
 * that we make inside of it. We use this code to make the client prove that they can read the cookie which means we know that
 * the cookie is sent by the same app domain that the cookie was created for. 
 * 
 * We also store this arbitrary code inside of our JWT payload to prove it was generated by the server, as an extra layer of security
 * even though it is not needed 
 * 
 * So we have these cookies sent from server:
 * 
 * HTTPOnly cookie: JWT token which includes { sessionId, clientId, csrfSecret },
 * SameSite cookie: csrfSecret
 * 
 * Now we just need to take advantage of the fact that requests made by an attacker on attacker.com will not be 
 * able to access the csrfSecret cookie's information (neither read nor write) for our application domain (also they obviously
 * won't be able to read/write the HTTPOnly one).
 * 
 * How we do this is by setting up our server architecture to not just simply authorize based on the existence of the JWT cookie.
 * The server must have a way of validating that the client is actually able to *read* the cookies that it is sending, which will
 * effectively prove they are on the domain that the cookie was made on (not cross-site). 
 * 
 * The way we have the client prove this is by making them have to read the secret from the csrfSecret cookie and attach it as a request
 * header to all their requests. So we will set a request header like
 * 
 * axios.defaults.headers.common['CSRF-TOKEN'] "some-url-encoded-random-key-obtained-from-csrfSecret"
 * 
 * This way clients have to not only have the cookie, but also prove that they can read the cookie (i.e theyre on the origin site). When
 * the server gets the request it will check the csrfSecret cookie as well as the header and make sure the secret is the same
 * 
 * https://stackoverflow.com/questions/65854195/csrf-double-submit-cookie-is-basically-not-secure
 * Mycotina's answer is insightful on this subject
 * 
 */
let con = mysql.createConnection({
    host: "localhost",
    user: "root",
    password: "InventoryManagementApp#!",
    database: "trackit",
  });
  
  con.connect(function(err) {
    if (err) throw err;
    console.log("Connected!");
  });