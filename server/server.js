
import mysql from 'mysql2'
import express, { json, urlencoded } from 'express'
import dotenv from 'dotenv';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import configureRoutes from './api/routes/configureRoutes.js';
import { currentTimeSeconds, minutesFromNow } from './utilities.js';
import authCheck from './api/middleware/authCheck.js';
import createDatabase from './api/tools/database/createDatabase.js';
import { Table } from './api/tools/database/ProcedureAbstractions.js';

const port = process.env.PORT || 4000;

dotenv.config();

const app = express()

// Set up cors (has to be first or HTTP req's get blocked)
app.use(cors({
    credentials: true,
    origin: [
        `http://localhost:${3000}`,
        `https://localhost:${3000}`
    ]
}));

// Set up JSON body parsing
app.use(json())
app.use(urlencoded({ extended: false }))
app.use(cookieParser())

app.use(authCheck);

// Configure REST API routes
configureRoutes(app);

// Connect to database
const con = mysql.createConnection({
    host: "localhost",
    user: "root",
    password: process.env.DATABASE_PASSWORD,
    database: "trackit",
});

export const db = createDatabase(con);

/*let invoiceId = 2;
Table("TblItemType")
    .select(["itemName", "itemId"])
    .join("TblMultiInvoiceItemType", { "itemId": "itemId" })
    .where({ "TblMultiInvoiceItemType.InvoiceId": invoiceId })
    .execute();*/

// Start
app.listen(port, () => {
    console.log("Server is up and running")

});

export default app;

/**
 * Here is how we will do authentication
 * 
 * We will use JWT token but be smart about how we store it. We will also use SQL to make them
 * more dynamic and cancellable
 * 
 * We will use the "double submit" strategy to prevent CSRF attack
 * 
 * Using the cookie itself as a form of authorization is dangerous, because other sites could could
 * socially-engineer you into clicking a link / running a script on their site that will make a request
 * a request in your browser. Since your browser will automatically send cookies it is dangerous because
 * they can make whatever request they want on your behalf (if your server architecture is set up in a way to
 * authorize based on the presence of the cookie)
 * 
 * To get around this we take advantage of a caveat of readable cookies on safe browsers: which is that on "normal/secure"
 * browsers like chrome, JavaScript code that is running on one website cannot read the cookies of other
 * websites. So what we do is instead of using cookies itself to authorize, we store authorizing info
 * (i.e the JWT token) in one cookie but we also have another cookie called the CSRF cookie that stores an arbritrary code
 * that we make inside of it. We use this code to make the client prove that they can read the cookie which means we know that
 * the cookie is sent by the same app domain that the cookie was created for. 
 * 
 * We also store this arbitrary code inside of our JWT payload to prove it was generated by the server, as an extra layer of security
 * even though it is not needed 
 * 
 * So we have these cookies sent from server:
 * 
 * HTTPOnly cookie: JWT token which includes { sessionId, clientId, csrfSecret },
 * SameSite cookie: csrfSecret
 * 
 * Now we just need to take advantage of the fact that requests made by an attacker on attacker.com will not be 
 * able to access the csrfSecret cookie's information (neither read nor write) for our application domain (also they obviously
 * won't be able to read/write the HTTPOnly one).
 * 
 * How we do this is by setting up our server architecture to not just simply authorize based on the existence of the JWT cookie.
 * The server must have a way of validating that the client is actually able to *read* the cookies that it is sending, which will
 * effectively prove they are on the domain that the cookie was made on (not cross-site). 
 * 
 * The way we have the client prove this is by making them have to read the secret from the csrfSecret cookie and attach it as a request
 * header to all their requests. So we will set a request header like
 * 
 * axios.defaults.headers.common['CSRF-TOKEN'] "some-url-encoded-random-key-obtained-from-csrfSecret"
 * 
 * This way clients have to not only have the cookie, but also prove that they can read the cookie (i.e theyre on the origin site). When
 * the server gets the request it will check the csrfSecret cookie as well as the header and make sure the secret is the same
 * 
 * https://stackoverflow.com/questions/65854195/csrf-double-submit-cookie-is-basically-not-secure
 * Mycotina's answer is insightful on this subject
 * 
 */